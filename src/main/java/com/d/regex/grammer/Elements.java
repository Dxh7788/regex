package com.d.regex.grammer;

/**
 * Copyright (C) 2017-2018 https://www.htouhui.com - A project by regex
 *
 * @author xh.d
 * @since 2018/2/8 9:51
 */
public final class Elements {

    /**
     * 非打印字符:
     * "\cx" 匹配由x指明的控制字符.例如,\cM匹配一个Ctrl+M 或者回车符的控制符.x的值必须为A-Z或者a-z之一.否则将c视为一个原义的'c'字符.
     * "\f"  匹配一个换页符号。等价于"\x0c"和\cL.
     * "\n"  匹配一个换行符号。等价于"\x0a"和\cJ
     * "\r"  匹配一个回车符.等价于"\x0d"和\cM
     * "\s"  匹配任何空白符号,如空格符号、换行符号、制表符号或者换页符号等.相当于[\r\f\n\t\v]
     * "\S"  匹配任何非空白符号,相当于[^\r\f\n\t\v]
     * "\t"  匹配一个制表符号,相当于\x09和\cl。
     * "\v"  匹配一个垂直指标符号,相当于\x0b和\cK.
     * */
    public static final String[] nonPrintCharsequence = {
            "\\cx","\f","\n","\r",
            "\\s","\\S","\t","\\v"
    };
    /**
     * 特殊字符
     * ^  匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 ^ 字符本身，请使用 \^。
     * $  匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 '\n' 或 '\r'。要匹配 $ 字符本身，请使用 \$。
     * () 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 \( 和 \)。
     * *  匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 \*。
     * +  匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 \+。
     * ?  匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \?。
     * .  匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 \.
     * [  标记一个中括号表达式的开始。要匹配 [，请使用 \[
     * \  将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如,'n' 匹配字符 'n'.'\n' 匹配换行符。序列 '\\' 匹配 "\"，而 '\(' 则匹配 "("。
     * {  标记限定符表达式的开始。要匹配 {，请使用 \{。
     * |  指明两项之间的一个选择。要匹配 |，请使用 \|。
     * */
    public static final String[] specialCharSequences = {
            "^", "$", "()", "*",
            "+", "?",".", "[",
            "\\", "{", "|"
    };

    /**
     *   *  代表字符至少匹配0次到多次,相当于{0,}
     *   +  代表字符至少匹配1次,相当于{1,}
     *   ?  代表字符至多匹配1次,匹配0次或者1次,相当于{0,1}
     *   {n} 代表匹配n次
     *   {n,} 代表至少匹配n次
     *   {n,m} 匹配n到m次
     * */
    public static final String[] limitCharSequences = {
         "*", "+", "?",
         "{n}", "{n,}","{n,m}"
    };

    /**
     * 定位符
     * 定位符使您能够将正则表达式固定到行首或行尾。它们还使您能够创建这样的正则表达式，这些正则表达式出现在一个单词内、在一个单词的开头或者一个单词的结尾。
     * 定位符用来描述字符串或单词的边界，^ 和 $ 分别指字符串的开始与结束，\b 描述单词的前或后边界，\B 表示非单词边界。
     *
     * ^  匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配
     * $  匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \n 或 \r 之前的位置匹配
     * \b 匹配一个字边界,即字和空格间的位置
     * \B 非字边界匹配.
     * 不能将限定符与定位符一起使用。由于在紧靠换行或者字边界的前面或后面不能有一个以上位置，因此不允许诸如 ^* 之类的表达式
     * 示例:
     * /^Chapter [1-9][0-9]{0,1}/ 匹配一个章节标题，该标题只包含两个尾随数字，并且出现在行首
     * /^Chapter [1-9][0-9]{0,1}$/ 真正的章节标题不仅出现行的开始处，而且它还是该行中仅有的文本。它即出现在行首又出现在同一行的结尾。下面的表达式能确保指定的匹配只匹配章节而不匹配交叉引用。通过创建只匹配一行文本的开始和结尾的正则表达式，就可做到这一点
     *
     * /\Bapt/  匹配 Chapter 中的字符串 apt，但不匹配 aptitude 中的字符串 apt,字符串 apt 出现在单词 Chapter 中的非字边界处，但出现在单词 aptitude 中的字边界处。对于 \B 非字边界运算符，位置并不重要，因为匹配不关心究竟是单词的开头还是结尾
     * */
    public static final String[] locationCharSequences = {
            "^","$","\b","\\B"
    };

    /**
     * 选择用圆括号将所有选择项括起来，相邻的选择项之间用|分隔。但用圆括号会有一个副作用，使相关的匹配会被缓存，此时可用?:放在第一个选项前来消除这种副作用。
     * 其中?:是非捕获元之一，还有两个非捕获元是 ?= 和 ?!，这两个还有更多的含义.
     * ?= 前者为正向预查，在任何开始匹配圆括号内的正则表达式模式的位置来匹配搜索字符串.
     * ?!为负向预查，在任何开始不匹配该正则表达式模式的位置来匹配搜索字符串。
     * */
}
